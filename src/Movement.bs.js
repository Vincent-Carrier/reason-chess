// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Base$ReasonChess = require("./Base.bs.js");
var Board$ReasonChess = require("./Board.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function translate(param, param$1) {
  return /* tuple */[
          param[0] + param$1[0] | 0,
          param[1] + param$1[1] | 0
        ];
}

function scale(param, n) {
  return /* tuple */[
          Caml_int32.imul(param[0], n),
          Caml_int32.imul(param[1], n)
        ];
}

function rotate(param) {
  return /* tuple */[
          -param[1] | 0,
          param[0]
        ];
}

function slide(param, towards, board, $staropt$star, $staropt$star$1, param$1) {
  var color = param.color;
  var canCapture = $staropt$star !== undefined ? $staropt$star : true;
  var max = $staropt$star$1 !== undefined ? $staropt$star$1 : 8;
  var _currentSq = translate(param.sq, towards);
  var _moves = /* [] */0;
  while(true) {
    var moves = _moves;
    var currentSq = _currentSq;
    var sqContent = Board$ReasonChess.at(currentSq, board);
    if (sqContent !== undefined) {
      var piece = sqContent;
      if (piece.color === color) {
        return moves;
      } else if (piece.color === Base$ReasonChess.Color.opposite(color) && canCapture) {
        return /* :: */[
                currentSq,
                moves
              ];
      } else {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "Movement.re",
                11,
                4
              ]
            ];
      }
    } else if (Board$ReasonChess.inside(currentSq) && max !== List.length(moves)) {
      if (Board$ReasonChess.inside(currentSq)) {
        _moves = /* :: */[
          currentSq,
          moves
        ];
        _currentSq = translate(currentSq, towards);
        continue ;
      } else {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "Movement.re",
                11,
                4
              ]
            ];
      }
    } else {
      return moves;
    }
  };
}

function four_directions(v) {
  var _directions = /* :: */[
    v,
    /* [] */0
  ];
  while(true) {
    var directions = _directions;
    var match = List.length(directions);
    if (match !== 4) {
      _directions = /* :: */[
        rotate(List.hd(directions)),
        directions
      ];
      continue ;
    } else {
      return directions;
    }
  };
}

exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.slide = slide;
exports.four_directions = four_directions;
/* Board-ReasonChess Not a pure module */
